几个排序算法实现 Java

冒泡
快排
插入
选择
堆
归并
希尔

  插入排序
有一个已经有序的数据序列中，要求在这个有序序列中插入一个数，插入之后仍然有序。
算法适用于少量数据的排序，时间复杂度为O(n^2)
这是稳定的排序算法，也就是说两个相等的书不会交换位置
对于向有序表中插入，通过从表尾开始顺序查找，

  插入排序算法：
1.从第一个元素开始，钙元素可以认为是已经有序的
2.取出下一个元素，在已经排序的元素序列中从后向前扫描；
3.如果该元素（已排序）大于新元素，那么将该元素移动到下一位置；
4.重复步骤3，直到找到已排序的元素小于或等于新元素的位置；
5.将新元素插入到新位置；
6.重复步骤2

  选择排序
1.在未排序的序列中找到最小元素，存放在序列的起始位置
2.再从剩余序列中继续寻找最小元素，然后放到排序序列末尾；
3.以此类推，直到所有元素均排序完毕。

这是一个不稳定的排序算法
平均时间复杂度O(n^2)

  希尔排序（缩小增量排序），直接插入排序的加强版
根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值移到后面；
最后对整个数组进行插入排序

  冒泡排序
比较相邻的元素，如果第一个比第二个大，就交换他们；
对每一对相邻元素做同样的工作，从开始第一对到结尾最后一对，这样的话，最后的元素应该会是最大的数；
针对所有元素重复上述步骤，除了最后一个；
持续每次对越来越少的元素重复上面的步骤，知道没有任何一堆数字需要比较。

  快速排序
1.首先选取第零位看作中间数；
2.从右往左开始扫描，也就是先从最后一位开始和这个中间数所对比，如果比他小，那么交换位置，比他大不做处理；
3.从右往左实现一次交换之后，改成从左向右扫描，看哪个数比中间数大，如果比他大，那么交换位置，
4.就这样从右向左、从左向右依次处理，一趟排序完成，左边就都是比中轴小，右边就都是比中轴大；
5.使用递归的方法重复对左边和右边的数进行上述操作。

  归并排序


  堆排序
首先是一个二叉堆的定义：
1.父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值
2.每个子节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）

当父节点的键值大于或等于任一个子节点的键值是为最大堆
当父节点你的键值总是小于或等于任何一个子节点的键值是为最小堆

一般使用数组来存储堆，i节点的父节点下表就为(i C 1) / 2, 它的左右节点的下标为2 * i + 1 和2 * i + 2.
每次的插入都是将新数据放在数组的最后面，显然，这个新数据的父节点到根节点必然是一个有序的数列，
那么插入就类似于直接插入排序中讲一个数据并与到有序区间中。
按照定义，堆的删除每次只能删除第0个数据，
为了便于重建堆，实际的操作是将最后一个数据的值付给根节点，然后从根节点开始一次从上向下的调整。
调整时先在左右儿子节点中找最小的，如果父节点比这个最小节点都还要小，那么就不需要调整了，
反之，将父节点与这个最小节点交换在考虑下面的节点
